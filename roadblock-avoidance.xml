<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
  <!ENTITY rfc2119 PUBLIC '' 'reference.RFC.2119.xml'>
  <!ENTITY rfc4034 PUBLIC '' 'reference.RFC.4034.xml'>
  <!ENTITY rfc4035 PUBLIC '' 'reference.RFC.4035.xml'>
  <!ENTITY rfc5155 PUBLIC '' 'reference.RFC.5155.xml'>
]>
<?rfc strict="no" ?>
<?rfc toc="yes" ?>
<?rfc tocdepth="3" ?>
<?rfc symrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<rfc category="bcp" ipr="trust200902" docName="draft-hardaker-dnsop-dnssec-roadblock-avoidance-FILLVERSION.txt">
  <front>
    <title abbrev="DNSSEC Roadblock Avoidance">
      DNSSEC Roadblock Avoidance
    </title>
    <author initials="W.H." surname="Hardaker" fullname="Wes Hardaker">
      <organization>Parsons</organization>
      <address>
        <postal>
          <street>P.O. Box 382</street>
          <city>Davis</city>
	  <region>CA</region>
          <code>95617</code>
          <country>US</country>
        </postal>
        <email>hardaker@tislabs.com</email>
      </address>
    </author>
    <author initials="O." surname="Gudmundsson" fullname="Olafur Gudmundsson">
      <organization>Shinkuro Inc.</organization>
      <address>
        <postal>
          <street>4922 Fairmont Av, Suite 250</street>
          <city>Bethesda</city>
          <region>MD</region>
          <code>20814</code>
          <country>USA</country>
        </postal>

        <email>ogud@ogud.com</email>
      </address>
    </author>
    <date day="4" month="July" year="2013"/>
    <area> OPS </area>
    <workgroup>DNSOP </workgroup> 
    <keyword>DNSSEC, Network Problems, DNS </keyword> 
    <abstract>
      <!-- $Revision: 1.28 $ -->
      <t>
        This document describes problems that a DNSSEC aware
        resolver/application might run into to
        non-compliant infrastructure.  It poses potential detection and
        mitigation techniques. The scope of the document is to create
        a shared approaches to detect and overcome network issues that
        a DNSSEC software/system may face. 
      </t>
    </abstract>
  </front>
  <middle>
    <section title="Introduction">
      <t>This document describes problems with DNSSEC (<xref
      target="RFC4034" />, <xref target="RFC4035" />) deployment due to
        non-compliant infrastructure.  It poses potential detection and
        mitigation techniques.
      </t>
      <t>
	The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
	"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
	document are to be interpreted as described in
	<xref target="RFC2119" />.
      </t>
    </section>
    <section title="Background">
      <t>Deployment of DNSSEC today is hampered by network
      components that make it difficult or sometimes impossible for
      validating stub resolvers to effectively obtain the DNSSEC data
      they need.  This can occur for many different reasons including 
	<list style="symbols"> 
          <t> because neighboring recursive resolvers are not fully
	    DNSSEC compliant </t> 
          <t>because "middle-boxes" active block outbound traffic to
            the DNS port (53) either UDP and/or TCP .</t>
          <t> Network component in path does not allow UDP
	    fragments</t> 
          <t>Resolver is not DNSSEC aware</t> 
          <t> etc. </t>
        </list> 
      </t>
      <t>This document talks about ways of detecting the state of the
      network a validating stub resolver might be attached to, and
      ways to hopefully circumvent the problems associated with the
      network defects it discovers.</t>
    </section>

    <section title="Notation"> 
      <t> When we talk about Validating Stub Resovler this can
	either be a library that an application has linked in or an
	actual resovler running on the same machine. </t> 
      <t> A variant of this is a Validating Forwarding Resolver,
	this is a resovler that is configured to use upstream
	Resolvers if possible. </t> 
      <t> ???? should we use the words Host Validator to cover all of
	these ? </t> 
    </section> 

    <section title="Goals">
      <t>The result of this work is intended to show how a validating
      stub resolver can detect the capabilities of a nearby recursive resolver
      whenever possible.  This enables the validating stub resolver to
      make use of the caching functionality in the recursive resolver,
      which decreases network traffic and increases response
      times.</t>

      <t>A validating stub resolver has two choices: it can wait to
      determine that it has problems with a recursive resolver based
      on the results that it is getting from legitimate queries issued
      to it, or it can proactively test for problems (Section <xref
      target="tests" />) to build a work around list ahead of time
      (Section <xref target="solutions" />).  There are pros and cons
      to both these paths that are application specific, and this
      document does not attempt to provide guidance about whether
      proactive tests should or should not be used.  Either way,
      however, DNSSEC roadblock avoidance techniques should be used
      when needed and if possible.</t>
    </section>

    <section title="Detecting DNSSEC Non-Compilance" anchor="tests">
      <t>A validating stub resolver must fist determine what
      bottlenecks exist that may hamper its ability to perform DNSSEC
      lookups.  This section outlines tests that can be done to test
      certain features of the surrounding network.</t>
      <section title="Determining DNSSEC support in neighboring recursive resolvers">
	<t>Ideally, a validating stub resolver can make use of the
	caching present in neighboring recursive resolvers.  This
	section discusses the tests that such a recursive resolver
	must pass in order to be fully usable as a near-by DNS
	cache.</t>
	<t>Unless stated otherwise, all of the following tests should
	have the recursive flag set when sending out a query.  Unless
	stated otherwise, the request should be sent over UDP.</t>
	<section title="Supports UDP answers">
	  <t>Purpose: This tests basic DNS over UDP functionality to a resolver.  </t>
	  <t>Test: A DNS
	  request should be sent to the resolver under test for an A
	  record for a known existing domain, such as
	  www.dnssec-tools.org.</t>
	  <t>SUCCESS: A DNS response was received that contains an a A
	  record in the answer section.  (The data itself does not need
	  to be checked.)</t>
	  <t>Note: an implementation MAY chose to not perform the rest
	  of the tests if this test fails, as clearly the resolver
	  under test is severely broken.</t>
	</section>
	<section title="Supports TCP answers">
	  <t>Purpose: This tests basic TCP functionality to a resolver.  </t>
	  <t>Test: A DNS
	  request should be sent over TCP to the resolver under test for an A
	  record for a known existing domain, such as
	  www.dnssec-tools.org.</t>
	  <t>SUCCESS: A DNS response was received that contains an a A
	  record in the answer section.  (The data itself does not need
	  to be checked.)</t>
	</section>

	<section title="Supports EDNS0">
	  <t>Purpose: Test whether a resolver properly supports the EDNS0
	  extension option.</t>
	  <t> Pre-requisite: "Supports UDP or TCP".</t>
	  <t>Test: Send a request to the resolver under test for an
	  A record for a known existing domain, such as
	  www.dnssec-tools.org, with ENDS0 OPT record in the additional section..</t>

	  <t>SUCCESS: A DNS response was received that contains at
	  an EDNS0 option with version number 0.</t>
	</section>

	<section title="Supports the DO bit">
	  <t>Purpose: This tests weather has minimal support of the DO bit.
	  </t>
	  <t> Pre-requisite: "Supports ENDS0".</t>
	  <t>Test: send a request to the resolver under test for an A record
	  for a known existing domain such as www.dnssec-tools.org.
	  Set the DO bit in the outgoing query.</t>
	  <t>SUCCESS: A DNS response was received that contains the DO
	  bit set.</t>
	  <t>Note: this only tests that the resolver sets the DO bit
	  in the response.  Later checks will determine if the DO bit
	  was actually made use of.  Some resolvers successfully pass
	  this test because they simply copy the unknown flags into
	  the response.  Don't worry, they'll fail the later tests.</t>
	</section>

	<section title="Supports the AD bit">
	  <t>Purpose: This weather the resolver is a validating
	  resolver.</t>
	  <t>Pre-requisite: "Supports EDNS0".</t>
	  <t>Test: Send a request to the resolver under test for an A
	  record for a known existing domain in a DNSSEC signed zone
	  which is verifiable to a configured trust anchor, such as
	  www.dnssec-tools.org using the root's published DNSKEY or DS
	  record as a trust anchor.  Set the DO bit in the outgoing
	  query.</t>

	  <t>SUCCESS: A DNS response was received that contains the AD
	  bit set.</t>
	</section>

	<section title="Returns RRsig for signed answer">
	  <t>Purpose: This tests whether a resolver will properly return RRSIG
	  records when the DO bit is set.</t>
	  <t>Pre-requisite: "Supports DO bit".</t>
	  <t>Test: Send a request to the resolver
	  under test for an A record for a known existing domain in a
	  DNSSEC signed zone, such as www.dnssec-tools.org.  Set the
	  DO bit in the outgoing query.</t>

	  <t>SUCCESS: A DNS response was received that contains at
	  least one RRSIG record.</t>
	</section>

	<section title="Supports querying for DNSKEY records">
	  <t>Purpose: This tests whether a resolver can query for and
	  receive a DNSKEY record from a signed zone.</t>
	  <t>Pre-requiste: "Supports DO bit."</t>
	  <t>Test: Send a request to the resolver under test for an DNSKEY
	  record which is known to exist in a signed zone, such as
	  dnssec-tools.org/DNSKEY.</t>
	  <t>SUCCESS: A DNS response was received that contains a
	   DNSKEY record in the answer section.</t>
	</section>
	<section title="Supports querying for DS records">
	  <t>Purpose: This tests whether a resolver can query for and
	    receive a DS record from a signed zone.</t>
	  <t>Pre-requiste: "Supports DO bit."</t>
	  <t>Test: Send a request to the resolver under test for an DS
	    record which is known to exist in a signed zone, such as
	    dnssec-tools.org/DS.</t>
	  <t>SUCCESS: A DNS response was received that contains a
	    DS record in the answer section.</t>
          <t> Note: Some DNSKEY RRsets are large and if the network
            path has problems with large answers this query may result
            in either false positive or false negative. In general the
            DNSKEY queried for should be a small enough to fit into 1220
            byte answer, to avoid false negative result when TCP is
	    disabled. </t> 
	</section>

	<section title="Supports negative answers  NSEC records">
	  <t>Purpose: This tests whether a resolver properly returns
	    NSEC records for a non-existing domain in a DNSSEC signed zone.</t>
	  <t>Pre-requiste: "Supports DO bit."</t>
	  <t>Test: Send a request to the resolver under test for an A
	    record which is known to not existing, such as
	    bogusdnstest.dnssec-tools.org.</t>
	  <t>SUCCESS: A DNS response was received that contains an
	    NSEC record.</t>
         <t>Note: The query issued in this test MUST be sent to a
           NSEC signed zone. Getting back appropriate NSEC3 records
           does not indicate a failure, but bad test.</t> 
	</section>

	<section title="Supports negative answers  NSEC3 records">
	  <t>Purpose: This tests whether a resolver properly returns
	  NSEC3 records (<xref target="RFC5155" />) for a non-existing
	  domain in a DNSSEC signed zone.</t>
	  <t>Pre-requiste: "Supports DO bit."</t>
	  <t>Test: Send a request to the resolver under test for an A
	  record which is known to not existing, such as
	  foobardedabadoo.org.</t>
	  <t>SUCCESS: A DNS response was received that contains an
	  NSEC3 record.</t>
         <t>Note: The query issued in this test MUST be sent to a
           NSEC3 signed zone. Getting back appropriate NSEC records
           does not indicate a failure, but bad test.</t> 
	</section>

	<section title="Supports queries where DNAME records lead to answer">
	  <t>Purpose: This tests whether a resolver can query for an A
	  record in a zone with a known DNAME referral for the record's
	  parent.</t>
	  <t>Test: Send a request to the resolver under test for an A
	  record which is known to exist in a signed zone within a
	  DNAME referral child zone, such as
	  good-a.dname-good-ns.test.dnssec-tools.net.</t>
	  <t>SUCCESS: A DNS response was received that contains a
	   DNAME in the answer section.  An RRSIG must also be
	  received in the answer section that covers the DNAME record.</t>
	</section>
	<section title="UDP size limits"> 
	  <t> TBD </t> 
	</section> 
      </section>

      <section title="Direct Network Queries">
	<t>If need be, a validating stub resolver may need to make
	direct queries to authoritative servers or known Open
	Recursive resolver in order to collect
	the data they require.  To do that, a number of key network
	features must be functional.</t>
	<section title="Remote UDP Support Over Port 53">
	  <t>Purpose: This tests basic UDP functionality to outside
	  the local network.</t>
	  <t>Test: A DNS
	  request should be sent to a known distant authoritative
	  server for a record known to be within that server's
	  authoritative data.  Example: send a query to the address of
	  ns1.dnssec-tools.org for the www.dnssec-tools.org/A record.</t>
	  <t>SUCCESS: A DNS response was received that contains an a A
	  record in the answer section.</t>
	  <t>Note: an implementation can used the local resolvers for
	  determining the address of the name server that is
	  authoritative for the given zone.  The recursive bit MAY be
	  set for this request, but does not need to be.</t>
	</section>
	<section title="Remote UDP Support With Fragmentation">
	  <t> Purpose: This tests if the local network can
	    recieve fragmented UDP answers</t> 
	  <t>Pre-requisite: Local UDP > 1500 is possible</t> 
          <t> Test: A DNS request should be sent over UDP to a known
            distant DNS address asking for a record that has answer larger than
            2000 bytes. Example send a query for the www.shinkuro.net/A
            record. </t>
          <t> Success: A DNS response was received that contains the
            large answer. </t> 
          <t> Note: A failure in getting large answers over UDP is not
            a serious problem unless TCP is not working.</t> 
	</section>

	<section title="Outbound TCP Support Over Port 53">
	  <t>Purpose: This tests basic TCP functionality to outside
	  the local network.</t>
	  <t>Test: A DNS
	  request should be sent over TCP to a known distant authoritative
	  server for a record known to be within that server's
	  authoritative data.  Example: send a query to the address of
	  ns1.dnssec-tools.org for the www.dnssec-tools.org/A record.</t>
	  <t>SUCCESS: A DNS response was received that contains an a A
	  record in the answer section.</t>
	  <t>Note: an implementation can used the local resolvers for
	  determining the address of the name server that is
	  authoritative for the given zone.  The recursive bit MAY be
	  set for this request, but does not need to be.</t>
	</section>
      </section>
    </section>

    <section title="Aggregating The Results">
      <t>Some conclusions can be drawn from the results of the above
      tests in an "aggregated" form.  This section defines some labels
      to assign to a resolver under test given the results of the
      tests run against them.</t>
      <section title="Resolver capability description"> 
	<t> This section will group and label certain common results TBD</t>
      </section>
    </section>

    <section title="Roadblock Avoidance" anchor="solutions">
      <t>Once we have determined what level of support is available in
      the neighboring network, we can determine what must be done in
      order to effectively act as a validating resolver.  This section
      discusses some of the options available given the results from
      the previous sections.</t>

      <t>For a stub resolver, problems with the recursive name server
        may manifest themselves as the following types of error
        conditions:</t>

      <t> <list style="symbols">
          <t>No response/error response.</t>
          <t>Illegal Response, which prevents the validator from
            fetching all necessary records required for constructing an
            authentication chain. This could result if referral loops
            are encountered, any of the antecedent zone delegations are lame, 
            aliases are erroneously followed for certain RRtypes (such as SOA,
            DNSKEYs or DS records), or if resource records for certiain
            types (e.g. DS) are not returned from the zone that is authoritative
            for them.</t> 
          <t>Bogus Response, when the cryptographic assertions in the
            authentication chain do not validate. </t> 
      </list> </t>
    
      <t> For each of the above error conditions a validator may adopt
      the following fallback techniques, preferring a particular approach if
      it is known to work for a given name server or zone from previous
      attempts or an initial probe sequence. </t> 

      <t> For each fallback technique, attempts to multiple potential
      name servers should be skewed such that the next name server is
      tried when the previous one encounters an error or a timeout is
      reached, whichever is earlier. </t> 

      <t> The validator should remember, in its zone-specific fallback
      cache, any broken behavior identified for a particular zone for 
      a duration of that zone's SOA negative TTL. </t>

      <t> The validator may place name servers that exhibit broken 
      behavior into a blacklist, and bypass these nameservers
      independently of the zone-specific fallback cache. 
      The validator must time out entries in this name server blacklist
      periodically, where this interval could be set to be the same as
      the DNSSEC BAD cache default TTL.</t>   

      <section title="No response/error response" anchor="noresp">        
          <t> <list style="symbols">
            <t> EDNS0 fallback [4096, 1492, None] </t>
            <t> TCP only </t>
            <t> alternative transport (to recursive name server) </t>
            <t> Iterative query to root if operating as a stub </t>
            <t> query alternative authoritative name server if operating in iterative mode </t>
          </list> </t>
      </section>

      <section title="Illegal Response Fallback">        
          <t> <list style="symbols">
            <t> Iterative query to root if operating as a stub </t>
            <t> query alternative authoritative name server if operating in iterative mode </t>
            <t> check for provably insecure status from closest trust anchor </t>
          </list> </t>
      </section>

      <section title="Bogus Response Fallback"> 
          <t> <list style="symbols">
            <t> If DNSSEC-meta data is missing follow <xref target="noresp"/> </t>
            <t> Iterative query to root if operating as a stub </t>
            <t> query alternative authoritative name server if operating in
                iterative mode </t>
          </list> </t>
      </section>

    </section>

    <section title="Start-Up and Network Connectivity Issues">
      <t>A number of scenarios will produce either short-term or
      long-term connectivity issues with respect to DNSSEC
      validation.  Consider the following cases:
      <list>
	<t>Time Synchronization: A device which has been off for a
	period of time and the clock is no longer in close
	synchronization with "real time".  This will cause problems
	when the device needs to resolve their source of time
	synchronization, such as "ntp.example.com".</t>
	<t>Changing Network Properties: A newly established network
	connection may change state shortly after a HTTP pay-wall
	authentication system has been used.  This especially common
	today in hotel networks, where validation, DNSSEC and even DNS
	are not functional until the user proceeds through a series of
	web pages to enable the network.  The tests in Section <xref
	target="tests" /> will produce very different results before and
	after the network authorization has succeeded.  APIs exist on
	many operating systems to detect initial network device status
	changes, such as right after DHCP has finished, but few
	(none?) exist to detect that a pay-wall has been authenticated
	through.</t>
      </list>
      </t>
      <t>There are only two choices when situations like this happen:
      <list>
	<t>Continue to perform DNSSEC processing, which will likely
	result in all DNS requests failing.  This is the most secure
	route, but causes the most operational grief for users.
	</t>
	<t>Turn of DNSSEC support until the network proves to be
	usable.  This allows the user to continue using the network,
	at the sacrifice of security.  It also allows for a denial of
	security-service attack if a man-in-the-middle can convince a
	device that DNSSEC is impossible.</t>
      </list>
      </t>
      <t>What to do: TBD</t>
    </section>

    <section title="IANA Considerations">
      <t>No IANA actions are require to support this document</t>
    </section>

    <section title="Security Considerations">
      <t>This document discusses problems that may occur while
      deploying the secure DNSSEC protocol and what mitigations can be
      used to help detect and midigate these problems.  Following
      these suggestions should result in a more secure DNSSEC
      operational environment than if DNSSEC was simply disabled when
      it fails to perform as expected.</t>
    </section>
    
    <section title="Acknowledgments">

      <t>Multiple lessons learned from multiple implementations led to
      the development of this document, including (in alphabetical
      order) DNSSEC-Tools' DNSSEC-Check, DNSSEC_Resolver_Check, dnssec-trigger, 
      FCC_Grade.
      </t>
      
      <t>The following people contributed to portions of this document
      in some fashion: ....
      </t>
    </section>
    
  </middle>
  <back>
    <references title="Normative References">
      &rfc2119;
      &rfc4034;
      &rfc4035;
      &rfc5155;
    </references>
  </back>
</rfc>
